<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Multi-processing en Python :: Supports</title>
    <link rel="canonical" href="https://jacquelincharbonnel.github.io/supports/concurrence/2024/multiprocessing/multiprocessing.html">
    <meta name="generator" content="Antora 3.1.14">
    <link rel="stylesheet" href="../../../_/css/site.css">
<!-- reference des feuilles de styles supplémentaires -->
<link rel="stylesheet" href="../../../_/css/layout.css">
<link rel="stylesheet" href="../../../_/css/content.css">

  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://jacquelincharbonnel.github.io/supports">Supports</a>
  <!-- suppression du burger du bandeau
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
-->      
    </div>
<!-- suppression des boutons du bandeau
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
      </div>
    </div>
-->
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="concurrence" data-version="2024">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Concurrence</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../introduction/intro.html">Aperçu</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../generateur/generateur.html">Générateur</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../asynchronisme/asyncio.html">Asynchronisme</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../aiohttp/collecte.html">Application #1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../asynchronisme/clientserveur/index.html">Application #2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../asynchronisme/bar/bar.html">Problème</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../multithreading/multithread.html">Multi-threading</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../multithreading/application.html">Application</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="multiprocessing.html">Multi-processing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="sequenceur/sequenceur.html">Problème 1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="anagrammes/anagrammes.html">Problème 2</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Concurrence</span>
    <span class="version">2024</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../../C/2023/index.html">C</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../C/2023/index.html">2023</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="../index.html">Concurrence</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">2024</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../linux_context/2025/index.html">Linux contexte</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../linux_context/2025/index.html">2025</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../python_objet/2024/index.html">Python objet</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../python_objet/2024/index.html">2024</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../supports/index.html">Supports</a></div>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../supports/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Concurrence</a></li>
    <li><a href="multiprocessing.html">Multi-processing</a></li>
  </ul>
</nav>
<!-- supression de "edit this page"
  <div class="edit-this-page"><a href="file:///home/jaclin/antora_components/concurrence/./modules/multiprocessing/pages/multiprocessing.adoc">Edit this Page</a></div>
-->
</div>
  <!-- ajout de la date de modification -->
     <div class="lastmodify"> dernière modification : 2024 </div>
  <!-- fin ajout -->
  <div class="content">
<aside class="toc sidebar" data-title="Plan" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Multi-processing en Python</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Le multi-processing consiste à exécuter, en même temps et indépendamment, un ensemble de tâches, chacune dans son contexte.
L&#8217;isolation est forte :
les tâches s&#8217;exécutent dans des espaces mémoire séparés, et ne partagent pas leurs variables.
Elles possèdent chacunes leur propre interpéteur Python.
Conséquence, les contextes peuvent être volumineux,
leur gestion
(création, destruction et commutation) peut être coûteuses (overhead).</p>
</div>
<div class="paragraph">
<p>Le module <code>multiprocessing</code> offre le moyen de faire du multi-processing en Python,
en offrant au
programmeur la possibilité de créer explicitement les tâches (sous forme d&#8217;instances de classe).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tâche"><a class="anchor" href="#_tâche"></a>1. Tâche</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Créer une tâche consiste à créer une sous-classe de <code>multiprocessing.Process</code>.
Cette sous-classe doit être dotée d&#8217;une méthode <code>run</code>
implémentant le traitement à réaliser.
Elle dispose (via l&#8217;héritage) d&#8217;une méthode <code>start</code> destinée à
lancer l&#8217;exécution de la tâche.
Exemple :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">import multiprocessing
...

class MyProcess(multiprocessing.Process):
  def __init__(self,...):
    multiprocessing.Process.__init__(self)
    ...

  def run(self):
    ...

if __name__ == '__main__':
  myprocess = MyProcess(...)
  myprocess.start()
  ...
  myprocess.join()
  ...</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bien que programmation multi-thread et programmation multi-processus
correspondent à 2 réalités bien différentes dans leur fonctionnement,
il existe une ressemblance d&#8217;utilisation
entre le module <code>multithreading</code>
et le module multiprocessing.
C&#8217;est une faculté de la POO de
proposer 2 classes offrant des interfaces similaires,
alors qu&#8217;en réalité leurs implémentations diffèrent fortement.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_le_multi_processing_vu_dunix"><a class="anchor" href="#_le_multi_processing_vu_dunix"></a>2. Le multi-processing vu d&#8217;Unix</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Les processus sur une machine Unix sont organisés en une arborescence,
visualisable avec la commande <code>pstree</code>.
Chaque processus possède un identifiant entier unique, son PID (visible avec <code>pstree -p</code>).
Hormis le premier processus, créé au boot de la machine,
tous les autres possèdent également un PPID,
qui n&#8217;est autre que le PID de leur père (visible avec <code>pstree -g</code>).</p>
</div>
<div class="paragraph">
<p>La terminaison d&#8217;un processus n&#8217;est pas suffisant pour qu&#8217;il disparaisse
sans laisser de trace :
même s&#8217;il ne fait plus rien,
les ressources qui lui ont été affectées (par exemple la mémoire) restent mobilisées.
C&#8217;est à son père de le faire disparaitre proprement, et ainsi restituer les ressources qu&#8217;il mobilisait.
Concrètement, le père doit acquitter la terminaison de son ou ses fils,
avec la méthode <code>join</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Tout processus dont la terminaison n&#8217;est pas acquittée par son père
subsiste en tant que processus zombie (<em>defunct</em>).
L&#8217;accumulation de tels processus encombre la machine, qui peut finir par manquer de ressources
et conduire à une congestion dont seul un reboot peut en sortir.
Conclusion : un programme ne doit pas laisser subsister des processus zombies.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_communication_inter_processus"><a class="anchor" href="#_communication_inter_processus"></a>3. Communication inter-processus</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Les processus ne partagent pas d&#8217;espace commun (donc pas de variables partagées),
ils doivent échanger leur données en communiquant.</p>
</div>
<div class="sect2">
<h3 id="_multiprocessing_pipe"><a class="anchor" href="#_multiprocessing_pipe"></a>3.1. <code>multiprocessing.Pipe</code></h3>
<div class="paragraph">
<p>C&#8217;est un <em>tuyau</em>, un canal de communication bidirectionnelle entre 2 processus, leur permettant d&#8217;échanger des données.
<code>multiprocessing.Pipe()</code>
renvoie une paire d&#8217;objets de type <code>Connection</code> représentant les 2 extrémités du tuyau.</p>
</div>
<div class="listingblock">
<div class="title">création d&#8217;un tuyau</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">from multiprocessing import Pipe
(a,b) = Pipe()
print(type(a).__name__)  # -&gt;  'Connection'
print(type(b).__name__)  # -&gt;  'Connection'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Un object <code>Connection</code> possède (entre autres) les méthodes
<code>send()</code> qui envoie des données dans le tuyau,
<code>recv()</code> qui récupère les données du tuyau,
<code>poll()</code> qui indique si des données sont présentes dans le tuyau, et
<code>close()</code> qui ferme la connexion.</p>
</div>
<div class="paragraph">
<p>Chacun des 2 processus embarque l&#8217;un des 2 objets <code>Connection</code> :</p>
</div>
<div class="listingblock">
<div class="title">émission, dans le 1er processus, via <code>a</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">a.send([1, 'hello', None])</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">réception, dans le 2nd processus, via <code>b</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">print(b.recv())  # [1, 'hello', None]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiprocessing_queue"><a class="anchor" href="#_multiprocessing_queue"></a>3.2. <code>multiprocessing.Queue</code></h3>
<div class="paragraph">
<p>La classe <code>multiprocessing.Queue</code> implémente l&#8217;échange de données entre processus.
Elle s&#8217;utilise aussi simplement qu&#8217;une liste.
Ce type est bien adapté au modèle producteur/consommateur.
Les processus qui veulent échanger partagent une même instance de <code>multiprocessing.Queue</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title"><code>Queue</code> vs <code>Pipe</code></div>
<div class="paragraph">
<p>Le tuyau est un concept de plus bas niveau que la queue, il nécessite la création explicite de connexions entre 2 processus. Conséquence, le tuyau est plus efficace et plus rapide, mais il est limité à 2 processus.
Une queue est plus abstraite, elle est manipulée comme une variable liste partagée entre plusieurs processus. Elle n&#8217;est pas limités à 2 processus.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Une queue peut avoir une taille donnée :</p>
</div>
<div class="listingblock">
<div class="title">queue de taille 100</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">queue = multiprocessing.Queue(maxsize=100)</code></pre>
</div>
</div>
<div class="paragraph">
<p>ou non fixée :</p>
</div>
<div class="listingblock">
<div class="title">queue sans taille spécifiée</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">queue = multiprocessing.Queue()</code></pre>
</div>
</div>
<div class="paragraph">
<p>On peut tester sa taille (<code>qsize()</code>), si elle est vide (<code>empty()</code>) ou pleine (<code>full()</code>).
L&#8217;ajout de valeurs se fait avec <code>put()</code>, et le retrait avec <code>get()</code>.</p>
</div>
<div class="paragraph">
<p>Exemple :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">import multiprocessing as mp

q = mp.Queue()
# remplissage
for i in range(10):
  q.put(i,block=False)
...
# vidage
while q.qsize()&gt;0:
  item = q.get(block=True)
  print(item)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Par défaut, ces opérations sont bloquantes.
Donc <code>put()</code> attend qu&#8217;il y ait de la place pour déposer la valeur :</p>
</div>
<div class="listingblock">
<div class="title">ajouter en mode bloquant</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">queue.put(item, block=True)
queue.put(item)               # équivalent</code></pre>
</div>
</div>
<div class="paragraph">
<p>et <code>get()</code> attend qu&#8217;il y ait quelque chose à prendre :</p>
</div>
<div class="listingblock">
<div class="title">retirer en mode bloquant</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">item = queue.get(block=True)
item = queue.get()            # équivalent</code></pre>
</div>
</div>
<div class="paragraph">
<p>On peut aussi les utiliser dans un mode non bloquant, auxquel cas <code>get()</code> et <code>put()</code> lancent une exception en cas d&#8217;impossibilité.
Dans ce mode, <code>put()</code> lance une <code>Full</code> exception lorsque la file est pleine :</p>
</div>
<div class="listingblock">
<div class="title">ajouter sans attendre</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">try:
  queue.put(item, block=False)
except queue.Full:
  # ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>et <code>get()</code> lance une <code>Empty</code> exception lorsque la file est vide :</p>
</div>
<div class="listingblock">
<div class="title">retirer sans attendre</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">try:
  item = queue.get(block=False)
except queue.Empty:
  # ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>On a aussi un mode mixte, dans lequel l&#8217;exception est lancée après un certain temps :</p>
</div>
<div class="listingblock">
<div class="title">essayer d&#8217;ajouter pendant 5s</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">try:
  queue.put(item, timeout=5)
except queue.Full:
  # ...</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">essayer de prendre pendant 10s</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">try:
  item = queue.get(timeout=10)
except queue.Empty:
  # ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>On ne doit pas gérer la concurrence par soi-même. Par exemple, ce code :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">if not queue.full():
  queue.put(item, block=False)</code></pre>
</div>
</div>
<div class="paragraph">
<p>n&#8217;est pas correct dans un environnement d&#8217;exécution concurrent
(car il est interruptible).</p>
</div>
<h4 id="_exemple_du_producteurconsommateur" class="discrete">Exemple du producteur/consommateur</h4>
<div class="listingblock">
<div class="title">producteur</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">def producteur(queue):
    print('Producteur: début', flush=True)
    for i in range(10):
        value = random()
        sleep(value)
        queue.put(value)
    queue.put(None)
    print('Producteur: fin', flush=True)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">consommateur</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">def consommateur(queue):
    print('Consommateur: début', flush=True)
    while True:
        item = queue.get()
        if not item:
            break
        print(f'&gt;retire {item}', flush=True)
    print('Consommateur: fin', flush=True)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_listener_et_client"><a class="anchor" href="#_listener_et_client"></a>3.3. Listener et Client</h3>
<div class="paragraph">
<p>Les communications précédentes sont limitées à la machine locale.
<code>multiprocessing.connection.Listener</code>
et
<code>multiprocessing.connection.Cient</code>
permettent des communications entre machines.</p>
</div>
<div class="listingblock">
<div class="title">Listener</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">from multiprocessing.connection import Listener

address = ('localhost', 6000)

with Listener(address, authkey=b'secret password') as listener:
  with listener.accept() as conn:
    print('connexion acceptée par', listener.last_accepted)
    data = conn.recv()
    print(f"reçu: {data}")
    ...
    print(f"envoi de {result})
    conn.send(result)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Client</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">from multiprocessing.connection import Client

address = ('localhost', 6000)

with Client(address, authkey=b'secret password') as conn:
  print(f"envoi de {data})
  conn.send(data)
  result = conn.recv()
  print(f"reçu: {result}")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Là encore, la méthode
<code>send()</code> envoie des données, et
<code>recv()</code> les récupère.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p class="center">
  <span style="font-size: 0.9em;">
    <a href="https://jacquelincharbonnel.github.io/">Jacquelin Charbonnel</a>
    <!-- &nbsp; &mdash; &nbsp; -->
    &nbsp;
    &copy;Creative Commons BY-NC-SA 4.0
  </span>
  </p>
</footer>

<script>
var myDate = new Date(document.lastModified);
myNewDate = new Intl.DateTimeFormat(
            undefined,
            {year: "numeric", month: "long", day: "numeric", hour: "2-digit", minute: "2-digit"}
        )
        .format(myDate).replace(/\./g, '-');
document.getElementById("lastmodify").innerHTML = myNewDate ;
</script>

<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
